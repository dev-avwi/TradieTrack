Perfect, here‚Äôs the full master prompt you can copy-paste into Replit.
This tells it exactly how to:
	‚Ä¢	use Stripe for:
	‚Ä¢	your SaaS subscriptions (tradie ‚Üí you)
	‚Ä¢	Stripe Connect for customer payments (customer ‚Üí tradie, with your fee)
	‚Ä¢	use SendGrid for:
	‚Ä¢	your app emails (you ‚Üí tradie)
	‚Ä¢	tradie‚Äôs business emails to their customers (via your SendGrid, with Reply-To set to tradie)

All designed so it‚Äôs simple for tradies, safe, and scalable.

‚∏ª

üß† MASTER REPLIT PROMPT ‚Äî STRIPE + STRIPE CONNECT + SENDGRID (TWO LAYERS)

I‚Äôm building a SaaS app called TradieTrack.

It‚Äôs a job, quote, invoice, team, and communication platform for tradies.
I‚Äôve already integrated Stripe and SendGrid at a basic level, but now I want a proper, two-layer setup:
	1.	Platform billing ‚Üí Tradies pay me for using TradieTrack (subscriptions)
	2.	Customer payments ‚Üí Tradies can connect their own Stripe to accept payments from their customers
	3.	App emails ‚Üí From me to tradies (welcome, billing, etc.)
	4.	Tradie emails ‚Üí From TradieTrack to tradies‚Äô customers (quotes/invoices), but using my SendGrid

Use this prompt as the source of truth for wiring up backend, frontend, DB, and email flows.

‚∏ª

0) Assumptions
	‚Ä¢	Frontend: React (TS preferred)
	‚Ä¢	Backend: Supabase (DB + Auth + Storage + Edge Functions) or equivalent API
	‚Ä¢	Payments:
	‚Ä¢	Stripe for my SaaS subscription billing
	‚Ä¢	Stripe Connect Express for tradies taking payments from their customers
	‚Ä¢	Emails:
	‚Ä¢	SendGrid with one main account for now
	‚Ä¢	We‚Äôll use:
	‚Ä¢	From: TradieTrack for {BusinessName} <no-reply@tradietrack.com>
	‚Ä¢	Reply-To: tradie‚Äôs real email

Environment variables (examples):
	‚Ä¢	STRIPE_SECRET_KEY
	‚Ä¢	STRIPE_WEBHOOK_SECRET
	‚Ä¢	STRIPE_CONNECT_WEBHOOK_SECRET (can be same or combined)
	‚Ä¢	SENDGRID_API_KEY
	‚Ä¢	APP_BASE_URL (e.g. https://app.tradietrack.com)

If the project already has some of these, reuse/clean them.

‚∏ª

1) DATABASE UPDATES

Extend or add tables as needed.

1.1 business table

Add or confirm fields:

business (
  id uuid primary key,
  name text,
  trade_type text,
  phone text,
  email text,
  abn text,
  address text,

  -- SaaS subscription (tradie ‚Üí me)
  subscription_tier text,         -- 'free' | 'starter' | 'pro' | 'elite'
  subscription_status text,       -- 'inactive' | 'active' | 'past_due' | 'canceled'
  stripe_customer_id text,
  stripe_subscription_id text,
  current_period_end timestamptz,

  -- Stripe Connect (customer payments ‚Üí tradie)
  stripe_connect_account_id text,
  connect_charges_enabled boolean,
  connect_payouts_enabled boolean,

  -- Email status
  email_verified boolean default false,

  created_at timestamptz default now()
);

1.2 users table

Confirm fields:

users (
  id uuid primary key,
  email text unique,
  full_name text,
  role text,                -- 'owner' | 'manager' | 'tradie'
  business_id uuid references business(id),
  created_at timestamptz default now()
);

1.3 invoices table (for customer payments)

Make sure invoices support online payments:

invoices (
  id uuid primary key,
  business_id uuid references business(id),
  job_id uuid references jobs(id),
  client_id uuid references clients(id),
  status text,              -- 'draft' | 'sent' | 'paid' | 'overdue'
  gst_included boolean,
  total_cents integer,      -- store in cents
  currency text default 'aud',
  due_date timestamptz,
  stripe_payment_intent_id text,
  payment_method text,      -- 'card', 'bank_transfer', etc
  payment_reference text,
  paid_at timestamptz,
  created_at timestamptz default now()
);

1.4 notifications table

We‚Äôll use this for app-level events:

notifications (
  id uuid primary key,
  business_id uuid references business(id),
  user_id uuid null,
  type text,         -- 'subscription_activated', 'payment_failed', 'invoice_paid', etc.
  title text,
  body text,
  related_type text, -- 'subscription', 'invoice', etc.
  related_id uuid,
  read boolean default false,
  created_at timestamptz default now()
);


‚∏ª

2) STRIPE LAYER 1: SAAS SUBSCRIPTIONS (TRADIE ‚Üí ME)

2.1 Plans

Define plans in Stripe (or via config in code):
	‚Ä¢	Starter ‚Üí e.g. price_starter_monthly
	‚Ä¢	Pro ‚Üí e.g. price_pro_monthly
	‚Ä¢	Elite ‚Üí e.g. price_elite_monthly

Store their IDs in env or config.

2.2 API: POST /api/billing/create-checkout-session

Purpose: When a tradie picks a plan in the Billing UI.

Input (from frontend):

{
  "businessId": "uuid",
  "userId": "uuid",
  "plan": "starter" | "pro" | "elite"
}

Backend logic:
	1.	Look up business and ensure userId belongs to it and is an owner/manager.
	2.	If stripe_customer_id missing, create customer:

const customer = await stripe.customers.create({
  email: ownerEmail,
  name: business.name,
  metadata: { business_id }
});

Store stripe_customer_id.

	3.	Map plan ‚Üí price_id.
	4.	Create Stripe Checkout Session:

const session = await stripe.checkout.sessions.create({
  mode: 'subscription',
  customer: business.stripe_customer_id,
  line_items: [{ price: priceId, quantity: 1 }],
  success_url: `${APP_BASE_URL}/billing?success=1`,
  cancel_url: `${APP_BASE_URL}/billing?cancelled=1`,
  metadata: {
    business_id: business.id,
    plan: plan
  }
});


	5.	Return session.url to frontend.

Frontend redirects user to that URL.

‚∏ª

2.3 Webhook: /api/stripe/subscription-webhook

Handle:
	‚Ä¢	checkout.session.completed
	‚Ä¢	invoice.payment_succeeded
	‚Ä¢	invoice.payment_failed
	‚Ä¢	customer.subscription.deleted or canceled

Logic for checkout.session.completed:
	1.	Verify webhook signature.
	2.	Get session object.
	3.	Read business_id and plan from session.metadata.
	4.	Fetch subscription from session.subscription.
	5.	Update business:

business.subscription_tier = plan;
business.subscription_status = 'active';
business.stripe_subscription_id = subscription.id;
business.current_period_end = subscription.current_period_end (converted to timestamp);


	6.	Insert notifications row:
	‚Ä¢	type: subscription_activated
	‚Ä¢	title: Subscription activated
	‚Ä¢	body: Your ${plan} plan is now active.
	7.	Optional: call SendGrid to send confirmation email to owner.

On invoice.payment_failed:
	‚Ä¢	Set subscription_status = 'past_due'
	‚Ä¢	Insert notification + email.

On customer.subscription.deleted or canceled:
	‚Ä¢	Set subscription_status = 'canceled'
	‚Ä¢	Optionally downgrade subscription_tier = 'free'
	‚Ä¢	Insert notification + email.

‚∏ª

2.4 Frontend: Billing Page

In /billing:
	‚Ä¢	Show current plan & status from business table.
	‚Ä¢	Plans cards:
	‚Ä¢	Free / Starter / Pro / Elite
	‚Ä¢	Upgrade buttons call /api/billing/create-checkout-session.
	‚Ä¢	Show success/error messages using URL params / query string.

Use subscription_status to show banners like:
	‚Ä¢	‚ÄúYour Pro plan is active.‚Äù
	‚Ä¢	‚ÄúPayment failed ‚Äì update your payment details.‚Äù

‚∏ª

3) STRIPE LAYER 2: TRADIE CUSTOMER PAYMENTS (STRIPE CONNECT)

Now for tradie ‚Üî customer payments.

3.1 API: POST /api/payments/create-connect-account-link

Used when tradie clicks ‚ÄúConnect Stripe‚Äù in Settings ‚Üí Payments.

Input:

{
  "businessId": "uuid",
  "userId": "uuid"
}

Backend logic:
	1.	Check user is owner or manager of businessId.
	2.	If business.stripe_connect_account_id exists:
	‚Ä¢	Retrieve account to see if charges/payouts enabled.
	‚Ä¢	If account exists, create an account link for updating:

const link = await stripe.accountLinks.create({
  account: business.stripe_connect_account_id,
  refresh_url: `${APP_BASE_URL}/settings/payments?refresh=1`,
  return_url: `${APP_BASE_URL}/settings/payments?connected=1`,
  type: 'account_onboarding'
});


	‚Ä¢	Return link.url.

	3.	If no account yet:
	‚Ä¢	Create stripeAccount:

const account = await stripe.accounts.create({
  type: 'express',
  email: business.email || ownerEmail,
  metadata: { business_id: business.id }
});


	‚Ä¢	Save stripe_connect_account_id to business.
	‚Ä¢	Create accountLinks.create same as above, return URL.

Frontend: redirect user to link.url.

‚∏ª

3.2 Webhook: /api/stripe/connect-webhook

Listen to account.updated events:
	‚Ä¢	Retrieve account object from Stripe.
	‚Ä¢	Use account.metadata.business_id or find business by stripe_connect_account_id.
	‚Ä¢	Update business:

business.connect_charges_enabled = account.charges_enabled;
business.connect_payouts_enabled = account.payouts_enabled;



Now you can show status in UI:
	‚Ä¢	if charges_enabled && payouts_enabled ‚Üí ‚ÄúPayments active‚Äù
	‚Ä¢	else ‚Üí ‚ÄúVerification pending‚Äù / ‚ÄúAction required‚Äù

‚∏ª

3.3 Invoices with online card payment

On an invoice detail page:
	‚Ä¢	If business.stripe_connect_account_id and connect_charges_enabled:
	‚Ä¢	Show toggle: ‚ÄúAllow online card payment‚Äù

When generating a public invoice payment page, you:
	1.	Have a URL like:
/pay/invoice/:invoiceId/:token
	2.	On that page:
	‚Ä¢	Show invoice summary, amount, and ‚ÄúPay now‚Äù button.
	3.	When customer clicks ‚ÄúPay now‚Äù:
	‚Ä¢	Frontend calls: POST /api/payments/create-payment-intent
Input:

{
  "invoiceId": "uuid"
}

Backend logic:
	1.	Fetch invoice + business.
	2.	Ensure:
	‚Ä¢	invoice.status === 'sent' or overdue
	‚Ä¢	business.stripe_connect_account_id is set
	‚Ä¢	connect_charges_enabled === true
	3.	Decide platform fee, e.g. 1.5%:

const platformFee = Math.round(invoice.total_cents * 0.015);


	4.	Create PaymentIntent:

const paymentIntent = await stripe.paymentIntents.create({
  amount: invoice.total_cents,
  currency: invoice.currency || 'aud',
  application_fee_amount: platformFee,
  on_behalf_of: business.stripe_connect_account_id,
  transfer_data: {
    destination: business.stripe_connect_account_id
  },
  metadata: {
    invoice_id: invoice.id,
    business_id: business.id
  }
});


	5.	Return client_secret or a Stripe Checkout URL.

	4.	Frontend:
	‚Ä¢	Use Stripe Elements or redirect to Checkout to complete the payment.
	5.	Webhook: In your main webhook (or connect webhook), handle payment_intent.succeeded:
	‚Ä¢	Retrieve paymentIntent.
	‚Ä¢	Use paymentIntent.metadata.invoice_id to find invoice.
	‚Ä¢	Update:

invoices.status = 'paid';
invoices.paid_at = now();
invoices.payment_method = 'card';
invoices.payment_reference = paymentIntent.id;


	‚Ä¢	Create notification:
	‚Ä¢	type: invoice_paid
	‚Ä¢	title: Invoice paid
	‚Ä¢	body: Invoice INV-XXXX has been paid.
	‚Ä¢	Trigger SendGrid email to:
	‚Ä¢	customer: receipt / confirmation
	‚Ä¢	tradie: ‚ÄúYour invoice was paid.‚Äù

‚∏ª

4) SENDGRID LAYER 1: APP EMAILS (YOU ‚Üí TRADIES)

Use sender:
	‚Ä¢	TradieTrack <no-reply@tradietrack.com>

Types of emails:
	‚Ä¢	Email verification
	‚Ä¢	Welcome
	‚Ä¢	Subscription activated
	‚Ä¢	Payment failed / canceled
	‚Ä¢	New feature announcements

Implement a backend helper:

sendAppEmail(to, template, data)

Internally:
	‚Ä¢	uses SENDGRID_API_KEY
	‚Ä¢	selects template ID based on template string
	‚Ä¢	fills dynamic_template_data with data

Examples:

sendAppEmail(owner.email, 'welcome', {
  name: owner.full_name,
  businessName: business.name
});

All app‚Üítradie emails use this.

‚∏ª

5) SENDGRID LAYER 2: TRADIE EMAILS (TRADIE ‚Üí THEIR CUSTOMERS)

Still sent via your SendGrid, but displayed as:
	‚Ä¢	From: TradieTrack for {BusinessName} <no-reply@tradietrack.com>
	‚Ä¢	Reply-To: business.email

So if a client replies ‚Üí tradie gets it directly.

Create another helper:

sendCustomerEmail(business, toEmail, type, data)
	‚Ä¢	From:
	‚Ä¢	name = "TradieTrack for " + business.name
	‚Ä¢	email = "no-reply@tradietrack.com"
	‚Ä¢	Reply-To: business.email

Types:
	‚Ä¢	quote_sent
	‚Ä¢	invoice_sent
	‚Ä¢	payment_receipt

Data might include:

{
  clientName,
  businessName,
  quoteNumber,
  invoiceNumber,
  amount,
  dueDate,
  publicUrl
}

Use different templates in SendGrid for each type.

‚∏ª

6) SETTINGS UI: PAYMENT & EMAIL STATUS

In Settings ‚Üí Business / Payments, show:

Billing (SaaS subscription)
	‚Ä¢	Plan: Free / Starter / Pro / Elite
	‚Ä¢	Status: active, past due, canceled
	‚Ä¢	Renewal date (current_period_end)
	‚Ä¢	Button: ‚ÄúChange plan‚Äù (calls /create-checkout-session)

Payments (customer payments)
	‚Ä¢	Stripe Connect status:
	‚Ä¢	Not connected:
	‚Ä¢	Button: ‚ÄúConnect Stripe to accept card payments‚Äù
	‚Ä¢	Connected but pending:
	‚Ä¢	Status: ‚ÄúStripe account connected, verification pending‚Äù
	‚Ä¢	Fully active:
	‚Ä¢	Status: ‚ÄúPayments enabled ‚Äì you can accept card payments on invoices.‚Äù
	‚Ä¢	Button: ‚ÄúManage Stripe account‚Äù (redirect to Stripe Express dashboard link)

Email verification
	‚Ä¢	If business.email_verified === false:
	‚Ä¢	Banner: ‚ÄúPlease verify your email to send quotes and invoices reliably.‚Äù
	‚Ä¢	Button: ‚ÄúResend verification email‚Äù (calls an endpoint that triggers sendAppEmail)

‚∏ª

7) SECURITY & SECRETS
	‚Ä¢	All Stripe secret keys and SendGrid keys must only exist in backend / Edge functions.
	‚Ä¢	Never exposed in frontend code.
	‚Ä¢	Verify webhook signatures for:
	‚Ä¢	/stripe/subscription-webhook
	‚Ä¢	/stripe/connect-webhook
	‚Ä¢	Make sure all calls that modify business settings, billing, or payments:
	‚Ä¢	check userId via auth
	‚Ä¢	confirm the user belongs to the businessId
	‚Ä¢	confirm they are an owner/manager

‚∏ª

8) TESTING SCENARIOS

Please add or suggest tests for:

Unit tests
	‚Ä¢	Plan ‚Üí price ID mapping
	‚Ä¢	Invoice total & GST calculations
	‚Ä¢	Correct building of email payloads (From/Reply-To, template data)
	‚Ä¢	Payment fee calculation

Integration tests
	‚Ä¢	Create business + user ‚Üí call /create-checkout-session ‚Üí validate session metadata
	‚Ä¢	Simulated subscription webhook ‚Üí ensure business.subscription_tier and status updated
	‚Ä¢	Simulated PaymentIntent webhook ‚Üí invoice marked as paid

Manual tests (document in comments/readme)
	‚Ä¢	New user signup ‚Üí verify email ‚Üí onboard business
	‚Ä¢	Upgrade to Pro ‚Üí Stripe checkout ‚Üí webhook ‚Üí app shows Pro plan
	‚Ä¢	Connect Stripe account ‚Üí see status in app
	‚Ä¢	Create invoice with online payment ‚Üí pay via Stripe ‚Üí invoice becomes paid ‚Üí emails sent

‚∏ª

9) GOAL

After implementing this spec, I want:
	‚Ä¢	A clean Billing page where tradies can subscribe to TradieTrack using my Stripe.
	‚Ä¢	A Payments settings page where tradies can connect their own Stripe account (Stripe Connect).
	‚Ä¢	Invoices that can optionally accept online card payments to the tradie‚Äôs Stripe account, with a small platform fee for me.
	‚Ä¢	SendGrid used for:
	‚Ä¢	app-level emails (me ‚Üí tradies)
	‚Ä¢	customer emails (tradies‚Äô customers) with:
	‚Ä¢	From: TradieTrack for {BusinessName} <no-reply@tradietrack.com>
	‚Ä¢	Reply-To: tradie‚Äôs email
	‚Ä¢	Clear status indicators and safe architecture, easy enough for tradies to understand and use.

Use this prompt as the architecture blueprint and update my existing Replit project to match it as closely as possible.

‚∏ª

You can drop that straight into Replit‚Äôs AI.

If you want next, I can help you:
	‚Ä¢	write the exact email texts (welcome, quote sent, invoice sent, payment receipt), or
	‚Ä¢	design the Settings ‚Üí Payments page layout so it looks clean and simple for tradies.